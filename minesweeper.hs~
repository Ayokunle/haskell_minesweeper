module Main where
import Graphics.UI.WX
import Control.Monad
import qualified Data.Map as M
import qualified Data.Set as S
import Data.Map(Map)
import System.Random


--Used this code as a starting point:
--https://gist.github.com/dancannon/4108039



type Pos = (Int, Int) -- (x, y) coordinates
type BoardDimensions = (Int,Int)

data InternalBoard = InternalBoard (Map Pos InternalSquare) deriving Show

data UserBoard = UserBoard (Map Pos UserSquare) deriving Show

-- | The possible states of a square in the board
data UserSquare
  = Undiscovered -- ^ An unclicked square
  | Clicked      -- ^ A clicked square
  | Flagged      -- ^ A square with a flag
  | Adjacent Int -- ^ A discovered square, where the number represents
                 --   the number of adjacent mines
  deriving (Eq, Show)
 
-- | Information about mines, not visible to the user
data InternalSquare
  = Mine          -- ^ This square is a mine
  | IAdjacent Int -- ^ This square is not a mine, but has n adjacent mines
  deriving (Eq, Show)
 
-- | The current state of the board
data GameState
  = GameState
    BoardDimensions
    UserBoard         -- ^ The user-visible board
    InternalBoard -- ^ Internal mine information
  deriving Show

adjacentPositions :: Pos -> [Pos]
adjacentPositions (x,y) = [(x-1,y-1),(x-1,y),(x-1,y+1),(x,y+1),(x+1,y+1),(x+1,y),(x+1,y-1),(x,y-1)]
 
allPositions :: BoardDimensions -> [Pos]
allPositions (w,h) = getRow w h
  where
    getCellsOfRow 1 y = [(1,y)]
    getCellsOfRow x y = (x,y) : getCellsOfRow (x-1) y
    getRow w 1 = getCellsOfRow w 1
    getRow w y = getCellsOfRow w y ++ getRow w (y-1)
 
generateBoard :: BoardDimensions -> Int -> IO GameState
generateBoard (w,h) num = do
  let poss = allPositions (w,h)
  mines <- getRandMines num (w,h) []
  let board = foldr (\pos acc -> (pos,Undiscovered):acc) [] poss
  let internal = foldr (\pos acc -> if (elem pos mines) then (pos,Mine):acc else let adjacent = foldr (\adjPos acc -> if (elem adjPos mines) then 1+acc else acc) 0 (adjacentPositions pos) in (pos,IAdjacent adjacent):acc) [] poss
  let state = GameState (w,h) (UserBoard (M.fromList board)) (InternalBoard (M.fromList internal))
  return state
  where
    getRandMines 0 _ mines =
      return mines
    getRandMines n (w, h) mines = do
      x <- getStdRandom(randomR (1, w))
      y <- getStdRandom(randomR (1, h))
      if elem (x,y) mines then
        getRandMines n (w, h) mines
      else
        getRandMines (n-1) (w, h) ((x, y):mines)


inBounds :: Pos -> BoardDimensions -> Bool
inBounds (x,y) (w,h) = x >= 1 && y >= 1 && x <= w && y <= h

printGameState :: GameState -> IO ()  
printGameState _ = do print "HI!"


main = do
    gs <- generateBoard (10,10) 7
    printGameState gs

{-main :: IO ()
main
  = start hello

hello :: IO ()
hello
  = do f    <- frame    [text := "Hello!"]
       quit <- button f [text := "Quit", on command := close f]
       set f [layout := widget quit]
-}
